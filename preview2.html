<!DOCTYPE html>

<head>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1">
    <title>Hello, world!</title>
    <!-- include three.js library -->
    <script src='js/three.js'></script>
    <script src='js/OBJLoader.js'></script>
    <script src='js/MTLLoader.js'></script>
    <!-- include jsartookit -->
    <script src="jsartoolkit5/artoolkit.min.js"></script>
    <script src="jsartoolkit5/artoolkit.api.js"></script>
    <!-- include threex.artoolkit -->
    <script src="threex/threex-artoolkitsource.js"></script>
    <script src="threex/threex-artoolkitcontext.js"></script>
    <script src="threex/threex-arbasecontrols.js"></script>
    <script src="threex/threex-armarkercontrols.js"></script>
    <script src="threex/threex-arsmoothedcontrols.js"></script>

    <script src="js/OrbitControls.js"></script>
    <script src="js/GLTFLoader.js"></script>
    <script src="js/DRACOLoader.js"></script>

    <script src="./js/preview-db2.js"></script>

    <link type="text/css" rel="stylesheet" href="./css/modelview2.css">

    <style>
        html,
        body {
            padding: 0;
            margin: 0;
            width: 100vw;
            height: 100vh;
        }

    </style>
</head>

<body style='overflow: hidden; font-family: Monospace;'>

    <div id="tray-container" style="display:none;"></div>

    <script>
        var scene, camera, renderer, clock, deltaTime, totalTime;

        var mixer;

        const tray = document.getElementById('tray-container');

        var arToolkitSource, arToolkitContext;

        var rootsAndControls = [];

        const INITIAL_MTL = new THREE.MeshPhongMaterial({
            color: 0x03fc4a
        });

        initialize();
        animate();

        function initialize() {
            scene = new THREE.Scene();

            let light0 = new THREE.DirectionalLight(0xcccccc, 1);
            light0.position.set(0, 3, 0);
            scene.add(light0);
            let light1 = new THREE.DirectionalLight(0xffffff, 1);
            light1.position.set(1, 1, 1);
            scene.add(light1);
            let light2 = new THREE.DirectionalLight(0xffffff, 1);
            light2.position.set(-1, 1, -1);
            scene.add(light2);
            let light3 = new THREE.DirectionalLight(0xffffff, 1);
            light3.position.set(0, -1, 2);
            scene.add(light3);

            camera = new THREE.Camera();
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setClearColor(new THREE.Color('lightgrey'), 0)
            renderer.setSize(1280, 960);
            renderer.domElement.style.position = 'fixed'
            renderer.domElement.style.width = '100vw'
            renderer.domElement.style.height = '100vh'
            renderer.domElement.style.top = '0px'
            renderer.domElement.style.left = '0px'
            renderer.domElement.style.right = '0px'
            renderer.domElement.style.bottom = '0px'
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();
            deltaTime = 0;
            totalTime = 0;

            ////////////////////////////////////////////////////////////
            // setup arToolkitSource
            ////////////////////////////////////////////////////////////

            arToolkitSource = new THREEx.ArToolkitSource({
                sourceType: 'webcam',
            });

            function onResize() {
                arToolkitSource.onResize()
                arToolkitSource.copySizeTo(renderer.domElement)
                if (arToolkitContext.arController !== null) {
                    arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
                }
            }

            arToolkitSource.init(function onReady() {
                onResize()
            });

            // handle resize event
            window.addEventListener('resize', function() {
                onResize()
            });

            ////////////////////////////////////////////////////////////
            // setup arToolkitContext
            ////////////////////////////////////////////////////////////	

            // create atToolkitContext
            arToolkitContext = new THREEx.ArToolkitContext({
                cameraParametersUrl: 'data/camera_para.dat',
                detectionMode: 'mono'
            });

            // copy projection matrix to camera when initialization complete
            arToolkitContext.init(function onCompleted() {
                camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
            });

            ////////////////////////////////////////////////////////////
            // setup markerRoots
            ////////////////////////////////////////////////////////////

            load3Dmodels();
        }

        function load3Dmodel(item) {
            let modelData = item.model;
            if (typeof modelData.pattern === 'undefined') {
                return;
            }

            // interpolates from last position to create smoother transitions when moving.
            // parameter lerp values near 0 are slow, near 1 are fast (instantaneous).
            let root = new THREE.Group();
            scene.add(root);
            let smoothedControl = new THREEx.ArSmoothedControls(root, {
                lerpPosition: 0.8,
                lerpQuaternion: 0.8,
                lerpScale: 1,
                // minVisibleDelay: 1,
                // minUnvisibleDelay: 1,
            });

            // build markerControls
            let markerControls = new THREEx.ArMarkerControls(
                arToolkitContext,
                root, {
                    type: 'pattern',
                    patternUrl: "data/" + modelData.pattern + ".patt",
                }
            );

            let modelPath = modelData.path;
            let pos = modelData.pos;
            let rot = modelData.rot;
            let animated = modelData.animated;
            let looponce = modelData.looponce;

            if (pos == undefined) pos = {
                z: 0,
                y: 0,
                x: 0
            };
            if (rot == undefined) rot = {
                z: 0,
                y: 0,
                x: 0
            };
            let loader = new THREE.GLTFLoader();

            let dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('./draco/');
            loader.setDRACOLoader(dracoLoader);
            let meshItem;
            loader.load(modelPath, function(load_model) {
                meshItem = load_model.scene;
                //meshItem.material.side = THREE.DoubleSide;
                let scale = modelData.scale * 0.25;
                meshItem.scale.set(scale, scale, scale);
                meshItem.position.x += pos.x;
                meshItem.position.y += pos.y;
                meshItem.position.z += pos.z;
                meshItem.rotation.x += rot.x;
                meshItem.rotation.y += rot.y;
                meshItem.rotation.z += rot.z;
                if (modelPath.includes("gfp")) {
                    initColor(meshItem, "GFP", INITIAL_MTL);
                } else {
                    renderer.outputEncoding = THREE.sRGBEncoding;

                }

                if (animated) {
                    modelData.actions = [];
                    console.log(load_model.animations);
                    modelData.mixer = new THREE.AnimationMixer(meshItem);
                    for (let i = 0; i < load_model.animations.length; i++) {
                        let action = modelData.mixer.clipAction(load_model.animations[i]);
                        if (looponce) {
                            action.setLoop(THREE.LoopOnce);
                            action.clampWhenFinished = true;
                        }
                        modelData.actions.push(action);
                        if (modelData.visible) {
                            action.play();
                        }
                    }
                }

                root.add(meshItem);
            }, function(xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            }, function(error) {
                console.error('Error loading the model (load3Dmodel)\n');
                console.error(error);
            });
            if (modelPath.includes("gfp")) {
                initGfpColors(meshItem);
            } //*/
            modelData.visible = false;
            modelData.root = root;
            modelData.control = smoothedControl;
        }

        function load3Dmodels() {
            for (let item of data) {
                load3Dmodel(item);
            }
        }


        function update() {
            // update artoolkit on every frame
            if (arToolkitSource.ready !== false)
                arToolkitContext.update(arToolkitSource.domElement);

            // additional code for smoothed controls
            for (let item of data) {
                if (item.model.control === undefined) continue;
                item.model.control.update(item.model.root);
            }

            // start animation depending on model
            for (let item of data) {
                if (item.model.root === undefined) continue;
                if (item.model.root.visible !== item.model.visible) {
                    item.model.visible = item.model.root.visible;
                    if (item.model.visible) {
                        item.onVisible();
                        for (let action of item.model.actions) {
                            action.play();
                        }
                    } else {
                        item.onHidden();
                        for (let action of item.model.actions) {
                            action.stop();
                        }
                    }
                }
            }
        }


        function animate() {
            requestAnimationFrame(animate);
            deltaTime = clock.getDelta();
            totalTime += deltaTime;

            for (let item of data) {
                if (item.model.mixer != null) item.model.mixer.update(deltaTime);
            }
            update(); // AR update
            renderer.render(scene, camera); // model update
        }



        function initColor(parent, type, mtl) {
            parent.traverse((o) => {
                if (o.isMesh) {
                    if (o.name.includes(type)) {
                        o.material = mtl;
                        o.nameID = type; // Set a new property to identify this object
                    }
                }
            });
        }

        function initGfpColors() {
            //tray.style = "display: flex;";
            // const colors = ['03f4fc', '0303fc', 'fc03a1', 'f4fc03', '03fc4a', '6703fc', 'fc0303', ]; // old colors
            const colors = ['0CFC16', 'F2FC3B', 'FC8839', 'FC3D3D', '4040FC', '35A0FC', '3AEBFC', ];

            const setMaterial = (parent, type, mtl) => {
                parent.traverse((o) => {
                    if (o.isMesh && o.nameID != null) {
                        if (o.nameID == type) {
                            o.material = mtl;
                        }
                    }
                });
            }

            const selectSwatch = (e) => {
                let color = colors[parseInt(e.target.dataset.key)];
                let new_mtl = new THREE.MeshPhongMaterial({
                    color: parseInt('0x' + color),
                    shininess: 10
                });

                console.log("click " + color); // TODO: remove
                setMaterial(data[1].model.root.children[0], 'GFP', new_mtl);
                // TODO: don't use data[1], somehow find gfp yourself
            }


            const buildColors = (colors) => {
                for (let [i, color] of colors.entries()) {
                    let swatch = document.createElement('div');
                    swatch.classList.add('tray-swatch');
                    swatch.style.background = "#" + color;
                    swatch.setAttribute('data-key', i);
                    swatch.addEventListener('click', selectSwatch);
                    tray.append(swatch);
                }
            }

            buildColors(colors);
        }

    </script>

</body>

</html>
